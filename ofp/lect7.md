Лекция 7. Монады
================

![Хламидомонада — одноклеточная водоросль](Хламида Монада.jpg)

Здесь мы будем рассматривать монады в духе книги [Душкина Р. В. «Функциональное
Программирование на языке Haskell»][1].

Общее понятие монады
--------------------

**Монада (в программировании)** — абстракция, позволяющая описать некоторое
последовательное вычисление. Монада представляет собой

* «значение, полученное определённым образом»,
* «значение, завёрнутое в некоторый контейнер»,
* «значение, получаемое с некоторым побочным эффектом».

Монада — параметризованный тип, будем, в соответствии с традициями Хаскеля,
обозначать его `M a`, где `M` символизирует некоторый тип-контейнер, а `a` —
типовый параметр, показывающий, что в нём хранится.

Один из знакомых вам примеров — монада `Option[T]` в Scala, аналогичная
монада в Хаскеле носит имя `Maybe a`. Эта монада представляет собой значение,
которое может отсутствовать.

В Хаскеле монада должна реализовывать четыре операции:

* `return :: a -> M a` — заворачивает значение в монаду,
* `>>= :: M a -> (a -> M b) -> M b` (читается «bind») — операция связывания,
  берёт значение типа `a`, завёрнутое в монаду и применяет к нему функцию,
  преобразующую значение типа `a` в завёрнутое в монаду значение типа `b`.
* `>> :: M a -> M b -> M b` — связывает два действия, если значение, хранящееся
  в монаде. Эта конструкция является синтаксическим сахаром:
  ```
  ma >> mb   ≡   ma >>= (\_ -> mb)
  ```
  Здесь `\_ -> mb` — это лямбда (безымянная функция), которая принимает
  аргумент, его игнорирует и возвращает `mb`.
* `fail :: M a` — она вызывается, например, при неудаче сопоставления
  с образцом
  в нотации `do`, может вызываться явно. В большинстве реализаций монад
  она прерывает программу с ошибкой, однако, для монад `Maybe` и `List`
  возвращается пустое значение.

Операции `return` и `>>=` позволяют только «завернуть» значение в монаду,
но при этом не предусмотрено средств для того, чтобы значение из монады «вынуть».

Если функция возвращает значение, завёрнутое в монаду, то это значит, данное
значение было получено по факту какой-то одной цепочкой вычислений.

Для ряда полезных монад, обычно, предусмотрены способы «выйти» из монады,
извлечь из неё значение. Но это частные случаи, и не все монады их обязаны
предоставлять. В частности, монада `IO` (ввода-вывода в Haskell’е) таких
средств не предоставляет (за исключением небезопасной `unsafePerformIO`),
так что если функция возвращает значение, завёрнутое в эту монаду, то его
можно или проигнорировать (и зачем вызывать такую функцию), или связать
с другими монадическими вычислениями и вернуть из самой функции. В этом
случае функция, вызвавшая функцию, возвращающую `IO`, тоже сама неизбежно
возвратит монаду `IO`. Таким образом, «грязные» функции ввода-вывода однозначно
помечаются типом возвращаемого значения — значение, завёрнутое в монаду
ввода-вывода.

Программа на Хаскеле начинает вычисление с функции
```haskell
main :: IO ()
```
Действия, которые будут «вплетены» в возвращаемое значение функции `main`,
программа и выполнит. В Хаскеле единичный тип (unit) обозначается пустым
кортежем `()`, т.е. `IO ()` означает функцию с побочным эффектом и без
возвращаемого значения (с возвращаемым значением единичного типа).

(Квадроточие в Хаскеле означает указание типа)

Примеры монад
-------------
Мы уже упомянули монады `Maybe` и `IO` Хаскеля. Рассмотрим подробнее монаду
`Maybe`.

### Монада `Maybe`

Тип `Maybe` определён в Хаскеле следующим образом:
```haskell
data Maybe a = Just a | Nothing
```
Монадические операции определены следующим образом:

```haskell
return :: a -> Maybe a
return x = Just x

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
(Just x) >>= f = f x
Nothing  >>= f = Nothing

fail :: Maybe a
fail = Nothing
```
Допустим, у нас есть несколько операций, каждая из которых может или породить
значение, или завершиться неудачей. Нам нужно вернуть результат, если все они
завершились успешно, либо сообщить об отсутствии результата, если хотя бы одна
из них завершилась неудачей. Для этого операции должны возвращать значение,
завёрнутое в `Maybe`, для получения результата будем использовать связывание
монад.

Допустим, эти операции — `f`, `g`, `h`, входные данные, `a`, `b`, `c`, функциям
`g` и `h` будут требоваться какие-то промежуточные результаты вычислений.

Рассмотрим реализацию без использования монад:

```haskell
f :: A -> Maybe X
g :: B -> X -> Maybe Y
h :: C -> X -> Y -> Maybe Z

makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  case (f a) of
    Just x -> case (g b x) of
                Just y -> h c x y
                Nothing -> Nothing
    Nothing
```

Очевидно, что приходится постоянно ветвиться — на каждом шаге проверять,
что значение есть, иначе передавать `Nothing`.

С использованием монад запись получается короче:
```haskell
makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  (f a) >>= (\x -> (g b x) >>= (\y -> (h c x y)))
```
Видно, что описывается лишь связь вычислений, а проверка на наличие или
отсутствие значения инкапсулируется внутри монады.

Для краткости в Хаскеле используется синтаксический сахар, так называемая
do-нотация:
```haskell
makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  do x <- (f a)
     y <- (g b x)
     (h c x y)
```
do-нотация неявно преобразуется в вызовы операции `>>=`.

### Монада `State`
В чистом языке программирования результаты любой функции определяется
только значениями аргументов функции, функция не может взять ниоткуда,
кроме как из аргументов и не может никуда деть, кроме как отбросить
или возвратить. Поэтому, если концептуально алгоритм предполагает некоторое
общее глобальное состояние (например, методика рекурсивного спуска
подразумевает наличие глобальной переменной с текущим анализируемым символом),
это «глобальное состояние» приходится «протаскивать» через каждую функцию,
передавая его аргументом и возвращая его как один из результатов (несколько
результатов, очевидно, эмулируются как возврат одного кортежа из нескольких
значений).

Монада `State` позволяет инкапсулировать в себе передачу дополнительного
аргумента-состояния и возврат пары «содержательный результат» + «обновлённое
состояние».









[1]: https://www.researchgate.net/publication/315642004_Functional_Programming_with_Haskell_Language
