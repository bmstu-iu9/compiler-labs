Лекция 7. Монады
================

![Хламидомонада — одноклеточная водоросль](Хламида Монада.jpg)

Здесь мы будем рассматривать монады в духе книги [Душкина Р. В. «Функциональное
Программирование на языке Haskell»][1].

Общее понятие монады
--------------------

**Монада (в программировании)** — абстракция, позволяющая описать некоторое
последовательное вычисление. Монада представляет собой

* «значение, полученное определённым образом»,
* «значение, завёрнутое в некоторый контейнер»,
* «значение, получаемое с некоторым побочным эффектом».

Монада — параметризованный тип, будем, в соответствии с традициями Хаскеля,
обозначать его `M a`, где `M` символизирует некоторый тип-контейнер, а `a` —
типовый параметр, показывающий, что в нём хранится.

Один из знакомых вам примеров — монада `Option[T]` в Scala, аналогичная
монада в Хаскеле носит имя `Maybe a`. Эта монада представляет собой значение,
которое может отсутствовать.

В Хаскеле монада должна реализовывать четыре операции:

* `return :: a -> M a` — заворачивает значение в монаду,
* `>>= :: M a -> (a -> M b) -> M b` (читается «bind») — операция связывания,
  берёт значение типа `a`, завёрнутое в монаду и применяет к нему функцию,
  преобразующую значение типа `a` в завёрнутое в монаду значение типа `b`.
* `>> :: M a -> M b -> M b` — связывает два действия, если значение, хранящееся
  в монаде. Эта конструкция является синтаксическим сахаром:
  ```
  ma >> mb   ≡   ma >>= (\_ -> mb)
  ```
  Здесь `\_ -> mb` — это лямбда (безымянная функция), которая принимает
  аргумент, его игнорирует и возвращает `mb`.
* `fail :: M a` — она вызывается, например, при неудаче сопоставления
  с образцом
  в нотации `do`, может вызываться явно. В большинстве реализаций монад
  она прерывает программу с ошибкой, однако, для монад `Maybe` и `List`
  возвращается пустое значение.

Операции `return` и `>>=` позволяют только «завернуть» значение в монаду,
но при этом не предусмотрено средств для того, чтобы значение из монады «вынуть».

Если функция возвращает значение, завёрнутое в монаду, то это значит, данное
значение было получено по факту какой-то одной цепочкой вычислений.

Для ряда полезных монад, обычно, предусмотрены способы «выйти» из монады,
извлечь из неё значение. Но это частные случаи, и не все монады их обязаны
предоставлять. В частности, монада `IO` (ввода-вывода в Haskell’е) таких
средств не предоставляет (за исключением небезопасной `unsafePerformIO`),
так что если функция возвращает значение, завёрнутое в эту монаду, то его
можно или проигнорировать (и зачем вызывать такую функцию), или связать
с другими монадическими вычислениями и вернуть из самой функции. В этом
случае функция, вызвавшая функцию, возвращающую `IO`, тоже сама неизбежно
возвратит монаду `IO`. Таким образом, «грязные» функции ввода-вывода однозначно
помечаются типом возвращаемого значения — значение, завёрнутое в монаду
ввода-вывода.

Программа на Хаскеле начинает вычисление с функции
```haskell
main :: IO ()
```
Действия, которые будут «вплетены» в возвращаемое значение функции `main`,
программа и выполнит. В Хаскеле единичный тип (unit) обозначается пустым
кортежем `()`, т.е. `IO ()` означает функцию с побочным эффектом и без
возвращаемого значения (с возвращаемым значением единичного типа).

(Квадроточие в Хаскеле означает указание типа)

Примеры монад
-------------
Мы уже упомянули монады `Maybe` и `IO` Хаскеля. Рассмотрим подробнее монаду
`Maybe`.

### Монада `Maybe`

Тип `Maybe` определён в Хаскеле следующим образом:
```haskell
data Maybe a = Just a | Nothing
```
Монадические операции определены следующим образом:

```haskell
return :: a -> Maybe a
return x = Just x

(>>=) :: Maybe a -> (a -> Maybe b) -> Maybe b
(Just x) >>= f = f x
Nothing  >>= f = Nothing

fail :: Maybe a
fail = Nothing
```
Допустим, у нас есть несколько операций, каждая из которых может или породить
значение, или завершиться неудачей. Нам нужно вернуть результат, если все они
завершились успешно, либо сообщить об отсутствии результата, если хотя бы одна
из них завершилась неудачей. Для этого операции должны возвращать значение,
завёрнутое в `Maybe`, для получения результата будем использовать связывание
монад.

Допустим, эти операции — `f`, `g`, `h`, входные данные, `a`, `b`, `c`, функциям
`g` и `h` будут требоваться какие-то промежуточные результаты вычислений.

Рассмотрим реализацию без использования связывания монад:

```haskell
f :: A -> Maybe X
g :: B -> X -> Maybe Y
h :: C -> X -> Y -> Maybe Z

makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  case (f a) of
    Just x -> case (g b x) of
                Just y -> h c x y
                Nothing -> Nothing
    Nothing -> Nothing
```

Очевидно, что приходится постоянно ветвиться — на каждом шаге проверять,
что значение есть, иначе передавать `Nothing`.

С использованием связывания монад запись получается короче:
```haskell
makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  (f a) >>= (\x -> (g b x) >>= (\y -> (h c x y)))
```
Видно, что описывается лишь связь вычислений, а проверка на наличие или
отсутствие значения инкапсулируется внутри монады.

Для краткости в Хаскеле используется синтаксический сахар, так называемая
do-нотация:
```haskell
makeFGH :: A -> B -> C -> Maybe Z
makeFGH a b c =
  do x <- (f a)
     y <- (g b x)
     (h c x y)
```
do-нотация неявно преобразуется в вызовы операций `>>=` и `>>`.

Если перед `<-` располагается переменная, то синтаксический
сахар преобразуется по следующему правилу:
```
do var <- ma
   action1
   action2
   ...
↓ ↓ ↓
ma >>= \var -> do action1
                  action2
                  ...
```
В общем случае перед `<-` может располагаться образец,
тогда неявно вызывается операция `fail` в случае
неудачи сопоставления:
```
do pattern <- ma
   actions
   ...
↓
ma >>= \x -> case x of
               pattern -> do actions
                             ...
               _ -> fail
```
Если в do-нотации нет связывания, используется операция `>>`:
```
do action1
   action2
   ...
↓ ↓ ↓
action1 >> do action2
              ...
```

### Монада `State`
В чистом языке программирования результаты любой функции определяется
только значениями аргументов функции, функция не может взять ниоткуда,
кроме как из аргументов и не может никуда деть, кроме как отбросить
или возвратить. Поэтому, если концептуально алгоритм предполагает некоторое
общее глобальное состояние (например, методика рекурсивного спуска
подразумевает наличие глобальной переменной с текущим анализируемым символом),
это «глобальное состояние» приходится «протаскивать» через каждую функцию,
передавая его аргументом и возвращая его как один из результатов (несколько
результатов, очевидно, эмулируются как возврат одного кортежа из нескольких
значений).

Монада `State` позволяет инкапсулировать в себе передачу дополнительного
аргумента-состояния и возврат пары «содержательный результат» + «обновлённое
состояние».

Пример. У нас есть дерево, мы хотим все листья дерева пронумеровать
слева-направо, заменить значения в листьях на пары «номер»+«исходное значение».

```haskell
data Tree a = Leaf a | Node (Tree a) (Tree a)

enumTree :: Tree a -> Tree (Integer, a)
enumTree tree =
  let (tree', nextNum) = enumTreeRec tree 0 in
    tree'

enumTreeRec :: Tree a -> Integer -> (Tree (Integer, a), Integer)
enumTreeRec (Leaf x) num = (Leaf (num, x), num + 1)
enumTreeRec (Node t1 t2) n0 =
  let (t1', n1) = enumTreeRec t1 n0 in
    let (t2', n2) = enumTreeRec t2 n1 in
      (Node t1' t2', n2)
```
Здесь нам приходится «таскать» состояние, которое является счётчиком:
функция `enumTreeRec` принимает дополнительный параметр и возвращает
осмысленное значение и обновлённое состояние.

Функция `enumTreeRec`, как и все функции Хаскеля, каррированная,
принимает дерево и возвращает функцию, принимающую старое состояние
и возвращающую пару, содержащую актуальное значение и новое состояние.

Можно вот этот «хвост» `Integer -> (Tree (Integer, a), Integer)` «отрезать»
и инкапсулировать, говоря, что это на самом деле «дерево, вычисленное
в контексте, содержащем целое число».

В общем случае «значение `a` вычисленное в котексте `s`» имеет вид
```haskell
s -> (a, s)
```
и инкапсулируется в монаде `State s a`. Eсли сравнить с обозначением `M a`
из начала лекции, то здесь `M` это `State s` — контекст со значением
типа `s`. Параметр `a` может в ходе вычислений меняться, параметр `s`
остаётся при связывании неизменным.

Монада `State` определяется примерно так:

```haskell
data State s a = State s -> (a, s)

return :: a -> State s a
return x = \s -> (x, s)

(>>=) :: State s a -> (a -> State s b) -> State s b
(State sf) >>= f  =
  let sh = \s -> (let (a, s') = sf s in
                    let (State sg) = f a in
                      sg s') in
    State sh
```
Тип
```haskell
(>>=) :: State s a -> (a -> State s b) -> State s b
```
можно условно понять как
```haskell
(>>=) :: (s -> (a, s)) -> (a -> (s -> (b, s))) -> (s -> (b, s))
```
Для доступа к состоянию используются функции `get` и `put`:

```haskell
get :: State s s
get = State (\s -> (s, s))

put :: s -> State s ()
put s = State \_ -> ((), s)
```







[1]: https://www.researchgate.net/publication/315642004_Functional_Programming_with_Haskell_Language
