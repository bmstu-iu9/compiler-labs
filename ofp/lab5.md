Лабораторная работа № 5. Суперкомпиляция
========================================

<div id="toc"></div>
<script src="toc.js"></script>

Цель работы
-----------
1. Приобретение навыков описания абстрактного синтаксического дерева
   для модельного языка с испоьзованием case-классов Scala.
2. Изучение алгоритмов, используемых в суперкомпиляции программ.

Модельные языки
---------------
### 1. Рефал с многоместными функциями и без структурных скобок
#### Синтаксис и семантика

Функции на этом подмножестве Рефала имеют вид

    ИмяФункции {
      образец, образец, ... = выражение;
      ...
    }

Т.е. похожи на частичные функции Scala. Функции могут принимать несколько
параметров (в отличие от обычного Рефала), поэтому в левых частях
предложений может быть несколько образцов, перечисленных через запятую
(во всех предложениях должно быть одинаковое количество образцов).

Имена функций всегда начинаются с большой буквы.

Образец состоит из символьных констант (записываются в одинарных
кавычках), s-переменных (записываются как идентификатор, начинающийся
буквой `s`) и e-переменных (записываются как идентификатор, начинающийся
на `e`), причём e-переменных может быть не более одной.

Иначе говоря, образец задаётся следующей грамматикой:

    образец ::= образец-символа образец
              | образец образец-символа
              | e-переменная
              | ε

    образец-символа ::= символьная-константа
                      | s-переменная

Если в предложении несколько образцов, то e-переменные в нём повторяться
не могут. s-переменные могут повторяться как в одном образце, так и в разных.

Образец фактически представляет собой простое регулярное выражение, переменные
в котором соответствуют именованным группам: s-переменная `sX` соответствует
именованной группе `(?<sX>.)`, e-переменная `eX` — `(?<eX>.*)` (здесь точка
соответствует любому символу. При этом, повторные вхождения s-переменных
должны иметь равные значения, т.е. соответствуют обратным ссылкам `\k<sX>`.

Пустой образец для наглядности будем обозначать как `ε`.

Пример. Образец

    'A' s.X e.Mid s.X 'B'

соответствует регулярному выражению

    A(?<sX>.)(?<eMid>.*)\k<sX>B

Выражения в правой части предложений состоят из символов, переменных и вызовов
функций, которые записываются как

    <ИмяФункции аргумент, аргумент...>

число аргументов должно совпадать с числом образцов в предложениях вызываемой
функции. Примеры правой части:

    'a' <F eX>
    eTo <Replace sFrom, eTo, eRest>
    <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>
    <PairedLoop eStack '(', eRest>

Правые части, фактически, представляют собой строковые литералы с интерполяцией
подстановки переменных и вызовов функций. Примеры выше могут быть
оттранслированы на JavaScript следующим образом:

    `a${F(`${eX}`)}`
    `${eTo}${Replace(`${sFrom}`, `${eTo}, `${eRest}`)}`
    `${Minus(`${Mul(`${eB}`, `${eB}`)}`, `${Mul(`4`, `${Mul(`${eA}`, `${eC}`)}`)}`)}`
    `${PairedLoop(`${eStack}(`, `${eRest}`)}`

Очевидно, что этот код можно упростить, но наивный транслятор должен
оттранслировать именно так.

На этом языке несложно описать машину Тьюринга, поэтому он является
алгоритмически полным.

#### Примеры программ

Программа, заменяющая символы `'a'` и `'b'` на символ `'c'` (аналогичную
разбирали на лекции, но на Scala):

    Main {
      eX = <g <f eX>>;
    }

    f {
      'a' eX = 'b' <f eX>;
      sX eY = sX <f eY>;
      ε = ε;
    }

    g {
      'b' eX = 'c' <g eX>;
      sX eY = sX <g eY>;
      ε = ε;
    }

Функция, заменяющая в третьем аргументе символы из первого аргумента на строку
из второго аргумента

    Replace {
      sFrom, eTo, sFrom eRest = eTo <Replace sFrom, eTo, eRest>;
      sFrom, eTo, sOther eRest = sOther <Replace sFrom, eTo, eRest>;
      sFrom, eTo, ε = ε;
    }

Функция, решающая квадратные уравнения (предполагаем, что `Minus`, `Mul`,
`Plus`, `Div`, `Sqrt` где-то определены, числа представлены их десятичной
записью):

    SqEqRoot {
      eA, eB, eC = <SqRootCheckD <D eA, eB, eC>, eB, eA>;
    }

    D {
      eA, eB, eC = <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>;
    }

    SqRootCheckD {
      '-' eD, eB, eA = 'нет корней';
      '0', eB, eA = <Div <Neg eB>, <Mul '2', eA>>;
      eD, eB, eA =
        <Div <Minus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>> ';'
        <Div <Plus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>>;
    }

    Neg {
      '-' eX = eX;
      eX = '-' eX;
    }

Функция, проверяющая парность скобок в строке

    Paired {
      eX = <PairedLoop ε, eX>;
    }

    PairedLoop {
      ε, ε = 'T';
      eStack, ε = 'F';
      eStack, '(' eRest = <PairedLoop eStack '(', eRest>;
      eStack '(', ')' eRest = <PairedLoop eStack, eRest>;
      ε, ')' eRest = 'F';
      eStack, sOther eRest = <PairedLoop eStack, eRest>;
    }


### 2. Подмножество Scheme
Подмножество Scheme первого порядка, в котором допустимыми типами данных
являются закавыченные символы (`'name`), константы `#t`, `#f` и `'()`
и cons-ячейки.

В языке допустимы только следующие особые формы:

* `(define (‹имя› ‹параметры›) ‹выражение›)` — определяет функцию с заданным
  именем. Выражение может быть только одно. Безымянных функций («лямбд»)
  в языке нет.
* `(if ‹выражение1› ‹выражение2› ‹выражение3›)` — если `‹выражение1›` равно
  `#f`, вычисляется `‹выражение3›`, иначе — `‹выражение2›`.
* `(quote ‹идентификатор›)` или `'‹идентификатор›` — создание зацитированого
  символа. Цитировать списки запрещено, кроме цитаты пустого списка `'()`
  (он является символом).

В языке присутствуют только следующие встроенные функции (их невозможно
переопределить при помощи `define`):

* `(pair? x)` — возвращает `#t` или `#f`.
* `(eq? sym1 sym2)` — применима только к символам, если один из аргументов
  является cons-ячейкой — ошибка времени выполнения.
* `(car xs)`, `(cdr xs)` — применимы только к cons-ячейкам. Применение
  к символам приводит к ошибке времени выполнения.
* `(cons a b)` — создаёт cons-ячейку, аргументы могут быть любыми.

В правильно написанной программе аргументы функций `eq?`, `car` и `cdr`
должны быть ранее проверены при помощи `(if (pair? …) … …)`.

#### Пример программы

Программа, заменяющая `'a` и `'b` на `'c`:

```scheme
(define (main xs) (g (f xs)))

(define (f xs)
  (if (pair? xs)
      (if (pair? (car xs))
          (no-return)
          (if (eq? (car xs 'a))
              (cons 'b (f (cdr xs)))
              (cons (car xs) (f (cdr xs)))))
      '()))

(define (g xs)
  (if (pair? xs)
      (if (pair? (car xs))
          (no-return)
          (if (eq? (car xs 'b))
              (cons 'c (g (cdr xs)))
              (cons (car xs) (g (cdr xs)))))
      '()))

(define (no-return) (no-return))
```

Функция написана в предположении, что на входе всегда находится правильный
список — cons-ячейка, вторым элеметном которой может быть либо `'()`, либо
правильный список, поэтому последнее звено функции `f` и `g` игнорируют.

Поведение программы не определено на вложенных списках — на них она просто
зависает (зацикливается).

#### Рекомендуемое представление конфигураций

Конфигурации для этого подмножества Scheme рекомендуется представлять как
выражения, составленные из особой формы `if`, встроенных функций и параметров
двух видов: параметры типа «выражение» и параметры типа «символ». Параметры
типа «выражение» можно обозначать как идентификаторы, составленные из знака
`e` и порядкового номера, типа символ — знака `s` и порядкового номера.

Прогонка вызова функции `(pair? ei)` ветвится — в первой ветке вызов заменяется
на `#t` и выполняется подстановка `ei → (cons eNEW eNEW+1)`, где `NEW` —
следующее значение счётчика параметров, во второй ветке вызов заменяется
на `#f` и выполняется подстановка `ei → sNEW`.

Вызовы `(pair? (cons … …))` и `(pair? si)` выполняются однозначно, заменяясь,
соответственно, на `#t` и `#f`.

Аргументами _активного вызова_ функции `(eq? … …)` могут быть только символьные
константы и символьные параметры, наличие параметров-выражений и cons-ячеек
означает об ошибке в программе и невозможности построить граф суперкомпиляции.

Вызов вида `(eq? si sj)` при прогонке даёт две ветки — в первой ветке вызов
заменяется на `#t` и выполняется подстановка `si → sj`, во второй ветке вызов
заменяется на `#f`, никаких подстановок не выполняется (продвинутый
суперкомпилятор здесь должен добавлять отрицательную рестрикцию `si ≠ sj`,
но мы для упрощения рестрикции не рассматриваем).

Вызовы вида `(eq? si 'x)` и `(eq? 'x si)` прогоняются аналогично,
в положительной ветке добавляется сужение `si → 'x`, в отрицательной ничего
не добавляется (опять же, продвинутый суперкомпилятор должен добавлять
рестрикцию `si ≠ 'x`).

Вызовы вида `(eq? 'x 'x)` и `(eq? 'x 'y)` раскрываются однозначно и дают,
соответственно, `#t` и `#f`.

Выражение вида `(if ei ‹T› ‹F›)` интерпретируется как

```scheme
(if (pair? ei)
    ‹F›
    (if (eq? ei #f)
        <F>
        <T>))
```

Выражение вида `(if si ‹T› ‹F›)` интерпретируется как `(if (eq? si #f) ‹F› ‹T›)`.

### 3. Подмножество Scala с case-классами и частичными функциями

Подмножество Scala включает в себя определение case-классов, case-объектов
и методов единственного объекта `Main`. Case-классы могут иметь только следующий
вид:

```scala
case class ‹имя класса› (‹имя поля› : Any, ‹имя поля› : Any)
```

т.е. класс неявно наследует `Any`, содержит поля типа `Any` и не имеет тела.

Case-объекты определяются так:

```scala
case object ‹имя константы›
```

Методами класса `Main` могут быть только частичные функции типа `Any => Any`:

```scala
object Main {
  def ‹имя функции› : Any => Any = {
    case ‹образец› => ‹выражение›
    ...
  }
  ...
}
```

В образцах могут использоваться только case-классы и case-объекты, определённые
в текущей программе, а также имена переменных. Запрещено использовать константы
встроенных типов (например, числа), кортежи и типы стандартной библиотеки
(вроде `List`). В выражениях могут использоваться те же конструкции, что
и в образцах плюс вызовы функций.

Для описания функций нескольких переменных в данном подмножестве нужно явно
определить case-класс для кортежа и его использовать для передачи параметров:

```scala
case class Pair(first: Any, second: Any)

object Main {
  def first : Any => Any = {
    case Pair(f, _) => f
  }
  def second : Any => Any = {
    case Pair(_, s) => s
  }
  def swap : Any => Any = {
    case pair => Pair(second(pair), first(pair))
  }
}
```

Конечно, функцию `swap` можно описать и короче:

```scala
…

object Main {
  …
  def swap : Any => Any = {
    case Pair(f, s) => Pair(s, f)
  }
}
```

#### Пример программы

Программа, заменяющая в списке константы `A` и `B` на `C`, остальные значения
остаются неизменными:

```scala

case object A
case object B
case object C

case class Cons(car: Any, cdr: Any)
case object Nil_

object Main {
  def main : Any => Any = {
    case xs => g(f(xs))
  }
  def f : Any => Any = {
    case Cons(A, xs) => Cons(B, f(xs))
    case Cons(x, xs) => Cons(x, f(xs))
    case Nil_ => Nil_
  }
  def g : Any => Any = {
    case Cons(B, xs) => Cons(C, g(xs))
    case Cons(x, xs) => Cons(x, g(xs))
    case Nil_ => Nil_
  }
}
```

Пустой список здесь назван `Nil_`, т.к. `Nil` — библиотечная константа,
которой пользоваться запрещено.

### 4. Язык SLL

Язык SLL описан в препринтах по суперкомпиляции Анд.В. Климова и С.А. Романенко:

* Анд.В. Климов, С.А. Романенко. Суперкомпиляция: основные принципы и базовые
  понятия // Препринты ИПМ им. М.В.Келдыша. 2018. № 111. С. 1–36.
  [doi:10.20948/prepr-2018-111](http://doi.org/10.20948/prepr-2018-111)
  [PDF](http://keldysh.ru/papers/2018/prep2018_111.pdf)
* С.А. Романенко. Суперкомпиляция: гомеоморфное вложение, вызов по имени,
  частичные вычисления // Препринты ИПМ им. М.В.Келдыша. 2018. № 209. С. 1-32.
  [doi:10.20948/prepr-2018-209](http://doi.org/10.20948/prepr-2018-209)
  [PDF](http://keldysh.ru/papers/2018/prep2018_209.pdf)

Используемые алгоритмы и дополнительные материалы
-------------------------------------------------
### Проверка вложения Хигмана-Крускала
Отношение Хигмана-Крускала (гомеоморфное вложение) часто используется
в суперкомпиляции для формализации понятия «опасной похожести» двух
конфигураций.

Говорят, что выражение E1 гомеоморфно вкладывается в выражение E2
(обозначается как E1 ⊴ E2), если в выражении E2 можно стереть какие-либо
элементы (конструкторы, звенья списка и т.д.) таким образом, что получится
выражение E2′, совпадающее с E1 без учёта имён переменных.

Формально:

* `x ⊴ y` — любая переменная вкладывается в любую переменную,
* `C ⊴ C` — константа вкладывается в совпадающую с ней константу,
* `a ⊴ c(b1, …, bi, … bn)`, если `a ⊴ bi` — если выражение `a` вкладывается
  в одно из подвыражений `bi` выражения `c(b1, …, bn)`, то оно вкладывается
  во всё выражение,
* `c(a1, …, an) ⊴ c(b1, …, bn)` если `ai ⊴ bi` для всех `i ∈ 1…n` — два
  выражения имеют одинаковую «форму» и их подвыражения попарно вкладываются.

#### Примеры

### Наиболее тесное обобщение
### Семантика call-by-name и call-by-value

Варианты заданий
----------------
Знаком (\*) помечены задачи повышенного уровня сложности — +5 баллов.

Варианты по выбору студента, каждый вариант могут делать не более
двух студентов из каждой группы.

В рамках каждого из вариантов лабораторной работы нужно для выбранного
модельного языка описать абстрактное синтаксическое дерево с использованием
case-классов (достаточно ту его часть, которая используется в алгоритме)
и реализовать сам алгоритм.

1.  (\*\*) Рефал: шаг прогонки, семантика call-by-value.
2.  (\*) Рефал: проверка вложения Хигмана-Крускала.
3.  (\*) Рефал: обобщение двух выражений.
4.  (\*) Scheme: шаг прогонки, семантика call-by-name.
5.  Scheme: проверка вложения Хигмана-Крускала.
6.  Scheme: наиболее тесное обобщение двух выражений.
7.  (\*) Scala: шаг прогонки, семантика call-by-value.
8.  Scala: проверка вложения Хигмана-Крускала.
9.  Scala: наиболее тесное обобщение двух выражений.
10. (\*) SLL: шаг прогонки, семантика call-by-name.
11. SLL: проверка вложения Хигмана-Крускала.
12. SLL: наиболее тесное обобщение двух выражений.
