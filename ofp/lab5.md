Лабораторная работа № 5. Суперкомпиляция
========================================

Знаком (\*) помечены задачи повышенного уровня сложности — +5 баллов.

Варианты по выбору студента, каждый вариант могут делать не более
двух студентов из каждой группы.

В рамках каждого из вариантов лабораторной работы нужно для выбранного
модельного языка описать абстрактное синтаксическое дерево с использованием
case-классов (достаточно ту его часть, которая используется в алгоритме)
и реализовать сам алгоритм.

Модельные языки
---------------
### 1. Рефал с многоместными функциями и без структурных скобок
#### Синтаксис и семантика

Функции на этом подмножестве Рефала имеют вид

    ИмяФункции {
      образец, образец, ... = выражение;
      ...
    }

Т.е. похожи на частичные функции Scala. Функции могут принимать несколько
параметров (в отличие от обычного Рефала), поэтому в левых частях
предложений может быть несколько образцов, перечисленных через запятую
(во всех предложениях должно быть одинаковое количество образцов).

Имена функций всегда начинаются с большой буквы.

Образец состоит из символьных констант (записываются в одинарных
кавычках), s-переменных (записываются как идентификатор, начинающийся
буквой `s`) и e-переменных (записываются как идентификатор, начинающийся
на `e`), причём e-переменных может быть не более одной.

Иначе говоря, образец задаётся следующей грамматикой:

    образец ::= образец-символа образец
              | образец образец-символа
              | e-переменная
              | ε

    образец-символа ::= символьная-константа
                      | s-переменная

Если в предложении несколько образцов, то e-переменные в нём повторяться
не могут. s-переменные могут повторяться как в одном образце, так и в разных.

Образец фактически представляет собой простое регулярное выражение, переменные
в котором соответствуют именованным группам: s-переменная `sX` соответствует
именованной группе `(?<sX>.)`, e-переменная `eX` — `(?<eX>.*)` (здесь точка
соответствует любому символу. При этом, повторные вхождения s-переменных
должны иметь равные значения, т.е. соответствуют обратным ссылкам `\k<sX>`.

Пустой образец для наглядности будем обозначать как `ε`.

Пример. Образец

    'A' s.X e.Mid s.X 'B'

соответствует регулярному выражению

    A(?<sX>.)(?<eMid>.*)\k<sX>B

Выражения в правой части предложений состоят из символов, переменных и вызовов
функций, которые записываются как

    <ИмяФункции аргумент, аргумент...>

число аргументов должно совпадать с числом образцов в предложениях вызываемой
функции. Примеры правой части:

    'a' <F eX>
    eTo <Replace sFrom, eTo, eRest>
    <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>
    <PairedLoop eStack '(', eRest>

Правые части, фактически, представляют собой строковые литералы с интерполяцией
подстановки переменных и вызовов функций. Примеры выше могут быть
оттранслированы на JavaScript следующим образом:

    `a${F(`${eX}`)}`
    `${eTo}${Replace(`${sFrom}`, `${eTo}, `${eRest}`)}`
    `${Minus(`${Mul(`${eB}`, `${eB}`)}`, `${Mul(`4`, `${Mul(`${eA}`, `${eC}`)}`)}`)}`
    `${PairedLoop(`${eStack}(`, `${eRest}`)}`

Очевидно, что этот код можно упростить, но наивный транслятор должен
оттранслировать именно так.

На этом языке несложно описать машину Тьюринга, поэтому он является
алгоритмически полным.

#### Примеры программ

Программа, заменяющая символы `'a'` и `'b'` на символ `'c'` (аналогичную
разбирали на лекции, но на Scala):

    Main {
      eX = <g <f eX>>;
    }

    f {
      'a' eX = 'b' <f eX>;
      sX eY = sX <f eY>;
      ε = ε;
    }

    g {
      'b' eX = 'c' <g eX>;
      sX eY = sX <g eY>;
      ε = ε;
    }

Функция, заменяющая в третьем аргументе символы из первого аргумента на строку
из второго аргумента

    Replace {
      sFrom, eTo, sFrom eRest = eTo <Replace sFrom, eTo, eRest>;
      sFrom, eTo, sOther eRest = sOther <Replace sFrom, eTo, eRest>;
      sFrom, eTo, ε = ε;
    }

Функция, решающая квадратные уравнения (предполагаем, что `Minus`, `Mul`,
`Plus`, `Div`, `Sqrt` где-то определены, числа представлены их десятичной
записью):

    SqEqRoot {
      eA, eB, eC = <SqRootCheckD <D eA, eB, eC>, eB, eA>;
    }

    D {
      eA, eB, eC = <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>;
    }

    SqRootCheckD {
      '-' eD, eB, eA = 'нет корней';
      '0', eB, eA = <Div <Neg eB>, <Mul '2', eA>>;
      eD, eB, eA =
        <Div <Minus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>> ';'
        <Div <Plus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>>;
    }

    Neg {
      '-' eX = eX;
      eX = '-' eX;
    }

Функция, проверяющая парность скобок в строке

    Paired {
      eX = <PairedLoop ε, eX>;
    }

    PairedLoop {
      ε, ε = 'T';
      eStack, ε = 'F';
      eStack, '(' eRest = <PairedLoop eStack '(', eRest>;
      eStack '(', ')' eRest = <PairedLoop eStack, eRest>;
      ε, ')' eRest = 'F';
      eStack, sOther eRest = <PairedLoop eStack, eRest>;
    }


### 2. Подмножество Scheme
допустимыми атомами являются только зацитированнные
символы, функции только глобальные, допустимые управляющие конструкции
`(if (pair?  …) … …)` и `(if (eq? sym sym) … …)`
### 3. Подмножество Scala с case-классами и частичными функциями.
### 4. Язык SLL

(см. методички Климова и Романенко
[раз](http://keldysh.ru/papers/2018/prep2018_111.pdf),
[два](http://keldysh.ru/papers/2018/prep2018_209.pdf)).

Варианты заданий
----------------
1.  (\*\*) Рефал: шаг прогонки, семантика call-by-value.
2.  (\*) Рефал: проверка вложения Хигмана-Крускала.
3.  (\*) Рефал: обобщение двух выражений.
4.  (\*) Scheme: шаг прогонки, семантика call-by-name.
5.  Scheme: проверка вложения Хигмана-Крускала.
6.  Scheme: наиболее тесное обобщение двух выражений.
7.  (\*) Scala: шаг прогонки, семантика call-by-value.
8.  Scala: проверка вложения Хигмана-Крускала.
9.  Scala: наиболее тесное обобщение двух выражений.
10. (\*) SLL: шаг прогонки, семантика call-by-name.
11. SLL: проверка вложения Хигмана-Крускала.
12. SLL: наиболее тесное обобщение двух выражений.
