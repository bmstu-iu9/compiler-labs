Лабораторная работа № 5. Суперкомпиляция
========================================

<div id="toc"></div>
<script src="toc.js"></script>

Цель работы
-----------
1. Приобретение навыков описания абстрактного синтаксического дерева
   для модельного языка с испоьзованием case-классов Scala.
2. Изучение алгоритмов, используемых в суперкомпиляции программ.

Модельные языки
---------------
### 1. Рефал с многоместными функциями и без структурных скобок
#### Синтаксис и семантика

Функции на этом подмножестве Рефала имеют вид

    ИмяФункции {
      образец, образец, ... = выражение;
      ...
    }

Т.е. похожи на частичные функции Scala. Функции могут принимать несколько
параметров (в отличие от обычного Рефала), поэтому в левых частях
предложений может быть несколько образцов, перечисленных через запятую
(во всех предложениях должно быть одинаковое количество образцов).

Имена функций всегда начинаются с большой буквы.

Образец состоит из символьных констант (записываются в одинарных
кавычках), s-переменных (записываются как идентификатор, начинающийся
буквой `s`) и e-переменных (записываются как идентификатор, начинающийся
на `e`), причём e-переменных может быть не более одной.

Иначе говоря, образец задаётся следующей грамматикой:

    образец ::= образец-символа образец
              | образец образец-символа
              | e-переменная
              | ε

    образец-символа ::= символьная-константа
                      | s-переменная

Если в предложении несколько образцов, то e-переменные в нём повторяться
не могут. s-переменные могут повторяться как в одном образце, так и в разных.

Образец фактически представляет собой простое регулярное выражение, переменные
в котором соответствуют именованным группам: s-переменная `sX` соответствует
именованной группе `(?<sX>.)`, e-переменная `eX` — `(?<eX>.*)` (здесь точка
соответствует любому символу. При этом, повторные вхождения s-переменных
должны иметь равные значения, т.е. соответствуют обратным ссылкам `\k<sX>`.

Пустой образец для наглядности будем обозначать как `ε`.

Пример. Образец

    'A' s.X e.Mid s.X 'B'

соответствует регулярному выражению

    A(?<sX>.)(?<eMid>.*)\k<sX>B

Выражения в правой части предложений состоят из символов, переменных и вызовов
функций, которые записываются как

    <ИмяФункции аргумент, аргумент...>

число аргументов должно совпадать с числом образцов в предложениях вызываемой
функции. Примеры правой части:

    'a' <F eX>
    eTo <Replace sFrom, eTo, eRest>
    <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>
    <PairedLoop eStack '(', eRest>

Правые части, фактически, представляют собой строковые литералы с интерполяцией
подстановки переменных и вызовов функций. Примеры выше могут быть
оттранслированы на JavaScript следующим образом:

    `a${F(`${eX}`)}`
    `${eTo}${Replace(`${sFrom}`, `${eTo}, `${eRest}`)}`
    `${Minus(`${Mul(`${eB}`, `${eB}`)}`, `${Mul(`4`, `${Mul(`${eA}`, `${eC}`)}`)}`)}`
    `${PairedLoop(`${eStack}(`, `${eRest}`)}`

Очевидно, что этот код можно упростить, но наивный транслятор должен
оттранслировать именно так.

На этом языке несложно описать машину Тьюринга, поэтому он является
алгоритмически полным.

#### Примеры программ

Программа, заменяющая символы `'a'` и `'b'` на символ `'c'` (аналогичную
разбирали на лекции, но на Scala):

    Main {
      eX = <g <f eX>>;
    }

    f {
      'a' eX = 'b' <f eX>;
      sX eY = sX <f eY>;
      ε = ε;
    }

    g {
      'b' eX = 'c' <g eX>;
      sX eY = sX <g eY>;
      ε = ε;
    }

Функция, заменяющая в третьем аргументе символы из первого аргумента на строку
из второго аргумента

    Replace {
      sFrom, eTo, sFrom eRest = eTo <Replace sFrom, eTo, eRest>;
      sFrom, eTo, sOther eRest = sOther <Replace sFrom, eTo, eRest>;
      sFrom, eTo, ε = ε;
    }

Функция, решающая квадратные уравнения (предполагаем, что `Minus`, `Mul`,
`Plus`, `Div`, `Sqrt` где-то определены, числа представлены их десятичной
записью):

    SqEqRoot {
      eA, eB, eC = <SqRootCheckD <D eA, eB, eC>, eB, eA>;
    }

    D {
      eA, eB, eC = <Minus <Mul eB, eB>, <Mul '4', <Mul eA, eC>>>;
    }

    SqRootCheckD {
      '-' eD, eB, eA = 'нет корней';
      '0', eB, eA = <Div <Neg eB>, <Mul '2', eA>>;
      eD, eB, eA =
        <Div <Minus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>> ';'
        <Div <Plus <Neg eB>, <Sqrt eD>>, <Mul '2', eA>>;
    }

    Neg {
      '-' eX = eX;
      eX = '-' eX;
    }

Функция, проверяющая парность скобок в строке

    Paired {
      eX = <PairedLoop ε, eX>;
    }

    PairedLoop {
      ε, ε = 'T';
      eStack, ε = 'F';
      eStack, '(' eRest = <PairedLoop eStack '(', eRest>;
      eStack '(', ')' eRest = <PairedLoop eStack, eRest>;
      ε, ')' eRest = 'F';
      eStack, sOther eRest = <PairedLoop eStack, eRest>;
    }


### 2. Подмножество Scheme
Подмножество Scheme первого порядка, в котором допустимыми типами данных
являются закавыченные символы (`'name`), константы `#t`, `#f` и `'()`
и cons-ячейки.

В языке допустимы только следующие особые формы:

* `(define (‹имя› ‹параметры›) ‹выражение›)` — определяет функцию с заданным
  именем. Выражение может быть только одно. Безымянных функций («лямбд»)
  в языке нет.
* `(if ‹выражение1› ‹выражение2› ‹выражение3›)` — если `‹выражение1›` равно
  `#f`, вычисляется `‹выражение3›`, иначе — `‹выражение2›`.
* `(quote ‹идентификатор›)` или `'‹идентификатор›` — создание зацитированого
  символа. Цитировать списки запрещено, кроме цитаты пустого списка `'()`
  (он является символом).

В языке присутствуют только следующие встроенные функции (их невозможно
переопределить при помощи `define`):

* `(pair? x)` — возвращает `#t` или `#f`.
* `(eq? sym1 sym2)` — применима только к символам, если один из аргументов
  является cons-ячейкой — ошибка времени выполнения.
* `(car xs)`, `(cdr xs)` — применимы только к cons-ячейкам. Применение
  к символам приводит к ошибке времени выполнения.
* `(cons a b)` — создаёт cons-ячейку, аргументы могут быть любыми.

В правильно написанной программе аргументы функций `eq?`, `car` и `cdr`
должны быть ранее проверены при помощи `(if (pair? …) … …)`.

#### Пример программы

Программа, заменяющая `'a` и `'b` на `'c`:

```scheme
(define (main xs) (g (f xs)))

(define (f xs)
  (if (pair? xs)
      (if (pair? (car xs))
          (no-return)
          (if (eq? (car xs 'a))
              (cons 'b (f (cdr xs)))
              (cons (car xs) (f (cdr xs)))))
      '()))

(define (g xs)
  (if (pair? xs)
      (if (pair? (car xs))
          (no-return)
          (if (eq? (car xs 'b))
              (cons 'c (g (cdr xs)))
              (cons (car xs) (g (cdr xs)))))
      '()))

(define (no-return) (no-return))
```

Функция написана в предположении, что на входе всегда находится правильный
список — cons-ячейка, вторым элеметном которой может быть либо `'()`, либо
правильный список, поэтому последнее звено функции `f` и `g` игнорируют.

Поведение программы не определено на вложенных списках — на них она просто
зависает (зацикливается).

#### Рекомендуемое представление конфигураций

Конфигурации для этого подмножества Scheme рекомендуется представлять как
выражения, составленные из особой формы `if`, встроенных функций и параметров
двух видов: параметры типа «выражение» и параметры типа «символ». Параметры
типа «выражение» можно обозначать как идентификаторы, составленные из знака
`e` и порядкового номера, типа символ — знака `s` и порядкового номера.

Прогонка вызова функции `(pair? ei)` ветвится — в первой ветке вызов заменяется
на `#t` и выполняется подстановка `ei → (cons eNEW eNEW+1)`, где `NEW` —
следующее значение счётчика параметров, во второй ветке вызов заменяется
на `#f` и выполняется подстановка `ei → sNEW`.

Вызовы `(pair? (cons … …))` и `(pair? si)` выполняются однозначно, заменяясь,
соответственно, на `#t` и `#f`.

Аргументами _активного вызова_ функции `(eq? … …)` могут быть только символьные
константы и символьные параметры, наличие параметров-выражений и cons-ячеек
означает об ошибке в программе и невозможности построить граф суперкомпиляции.

Вызов вида `(eq? si sj)` при прогонке даёт две ветки — в первой ветке вызов
заменяется на `#t` и выполняется подстановка `si → sj`, во второй ветке вызов
заменяется на `#f`, никаких подстановок не выполняется (продвинутый
суперкомпилятор здесь должен добавлять отрицательную рестрикцию `si ≠ sj`,
но мы для упрощения рестрикции не рассматриваем).

Вызовы вида `(eq? si 'x)` и `(eq? 'x si)` прогоняются аналогично,
в положительной ветке добавляется сужение `si → 'x`, в отрицательной ничего
не добавляется (опять же, продвинутый суперкомпилятор должен добавлять
рестрикцию `si ≠ 'x`).

Вызовы вида `(eq? 'x 'x)` и `(eq? 'x 'y)` раскрываются однозначно и дают,
соответственно, `#t` и `#f`.

Выражение вида `(if ei ‹T› ‹F›)` интерпретируется как

```scheme
(if (pair? ei)
    ‹F›
    (if (eq? ei #f)
        <F>
        <T>))
```

Выражение вида `(if si ‹T› ‹F›)` интерпретируется как `(if (eq? si #f) ‹F› ‹T›)`.

### 3. Подмножество Scala с case-классами и частичными функциями

Подмножество Scala включает в себя определение case-классов, case-объектов
и методов единственного объекта `Main`. Case-классы могут иметь только следующий
вид:

```scala
case class ‹имя класса› (‹имя поля› : Any, ‹имя поля› : Any, …)
```

т.е. класс неявно наследует `Any`, содержит поля типа `Any` и не имеет тела.

Case-объекты определяются так:

```scala
case object ‹имя константы›
```

Методами класса `Main` могут быть только частичные функции типа `Any => Any`:

```scala
object Main {
  def ‹имя функции› : Any => Any = {
    case ‹образец› => ‹выражение›
    ...
  }
  ...
}
```

В образцах могут использоваться только case-классы и case-объекты, определённые
в текущей программе, а также имена переменных. Запрещено использовать константы
встроенных типов (например, числа), кортежи и типы стандартной библиотеки
(вроде `List`). В выражениях могут использоваться те же конструкции, что
и в образцах плюс вызовы функций.

Для описания функций нескольких переменных в данном подмножестве нужно явно
определить case-класс для кортежа и его использовать для передачи параметров:

```scala
case class Pair(first: Any, second: Any)

object Main {
  def first : Any => Any = {
    case Pair(f, _) => f
  }
  def second : Any => Any = {
    case Pair(_, s) => s
  }
  def swap : Any => Any = {
    case pair => Pair(second(pair), first(pair))
  }
}
```

Конечно, функцию `swap` можно описать и короче:

```scala
…

object Main {
  …
  def swap : Any => Any = {
    case Pair(f, s) => Pair(s, f)
  }
}
```

#### Пример программы

Программа, заменяющая в списке константы `A` и `B` на `C`, остальные значения
остаются неизменными:

```scala

case object A
case object B
case object C

case class Cons(car: Any, cdr: Any)
case object Nil_

object Main {
  def main : Any => Any = {
    case xs => g(f(xs))
  }
  def f : Any => Any = {
    case Cons(A, xs) => Cons(B, f(xs))
    case Cons(x, xs) => Cons(x, f(xs))
    case Nil_ => Nil_
  }
  def g : Any => Any = {
    case Cons(B, xs) => Cons(C, g(xs))
    case Cons(x, xs) => Cons(x, g(xs))
    case Nil_ => Nil_
  }
}
```

Пустой список здесь назван `Nil_`, т.к. `Nil` — библиотечная константа,
которой пользоваться запрещено.

### 4. Язык SLL

Язык SLL описан в препринтах по суперкомпиляции Анд.В. Климова и С.А. Романенко:

* Анд.В. Климов, С.А. Романенко. Суперкомпиляция: основные принципы и базовые
  понятия // Препринты ИПМ им. М.В.Келдыша. 2018. № 111. С. 1–36.
  [doi:10.20948/prepr-2018-111](http://doi.org/10.20948/prepr-2018-111)
  [PDF](http://keldysh.ru/papers/2018/prep2018_111.pdf)
* С.А. Романенко. Суперкомпиляция: гомеоморфное вложение, вызов по имени,
  частичные вычисления // Препринты ИПМ им. М.В.Келдыша. 2018. № 209. С. 1-32.
  [doi:10.20948/prepr-2018-209](http://doi.org/10.20948/prepr-2018-209)
  [PDF](http://keldysh.ru/papers/2018/prep2018_209.pdf)

Используемые алгоритмы и дополнительные материалы
-------------------------------------------------
### Прогонка, семантика call-by-name и call-by-value
При суперкомпиляции, как правило, рассматривают две семантики вычислений:

* `call-by-name` — ленивая семантика без мемоизации вычисленных значений.
  В конфигурации выбирается самая внешняя конструкция (вызов функции,
  а в модельной Scheme, ещё и `if`), которую можно выполнить, и выполняется
  шаг прогонки.

  Например, в модельном Scheme это может быть вызов вида `(car (cons e1 e2))`,
  вычисляющийся в `e1`, вызов функции `eq?`, аргументами которого являются
  символьные константы и символьные параметры, вызов `pair?` с аргументом
  cons-ячейкой, параметром или константным символом.

* `call-by-value` — семантика вызова по значению. В конфигурации выбирается
  самая внутренняя конструкция, которую можно вычислить.

(Ленивая семантика call-by-need рассматривалась Зехером в своей диссертации
[(Secher, 2002)](2002 Jens Peter Secher Thesis.pdf), она сложна, мы её
рассматривать не будем.)

Результатом шага прогонки должен быть `Option[List[(Cond, Conf)]]`,
где `Conf` — дочерняя конфигурация, а `Cond` — условие на дуге, ведущее
в неё.

Если исходная конфигурация была пассивной (в ней не было вызовов функций,
и, в случае с Scheme, операции `if`), то возвращается `None`, иначе —
`Some(children)`.

Условие на дуге, ведущей в дочерний узел, может быть тождественно истинным.
В частности, если шаг прогонки однозначен, то у конфигурации будет единственный
потомок, помеченный тождественно истинным условием.

Если аргумент не входит в область определения функции (возможно для вариантов
1, 7, 10), то список будет пустым (ни одно предложение функции не применимо
к аргументу).

В случае языка Scheme (вариант 4) возможен случай некорректной конфигурации
(вроде `(pair? e1 e2)`), в этом случае также условимся возвращать пустой
список.

Шаг прогонки выполняется так:

* выбирается подвыражение, которое можно выполнить (согласно семантике
  call-by-name или call-by-value) — вызов функции, для Scheme — ещё и `if`,
* спекулятивно вычисляется данное выражение — строятся результаты его
  вычисления и соответствующие им условия (во всех вариантах — сужения,
  либо тождественная истина),
* строятся потомки путём замены данного подвыражения на соответствующий
  результат и применения сужения (если оно есть) ко всему выражению.

В случае Scheme прогонке подвергаются вызовы `(pair? …)`, `(eq? … …)`
и `(if … … …)` так, как описано в разделе
о [представлении конфигураций](#рекомендуемое-представление-конфигураций).
Потомков у конфигурации может быть не более трёх (три потомка даёт раскрытие
`(if ei … …)`, т.к. параметр может быть cons-ячейкой, а также равен
и не равен `#f`).

В случае модельных языков Рефал, Scala и SLL потомков может быть сколько
угодно. Каждое предложение вызываемой функции может давать ноль и более
потомков (Рефал) или ноль и один потомок (Scala и SLL).

Если сопоставление ни с одним из образцов невозможно, то следует просто
вернуть пустой список.

Если в конфигурации можно выбрать несколько вызовов, подлежащих вычислению,
то выбирать можно любой. Обычно выбирают самый левый.

### Проверка вложения Хигмана-Крускала
Отношение Хигмана-Крускала (гомеоморфное вложение) часто используется
в суперкомпиляции для формализации понятия «опасной похожести» двух
конфигураций.

Говорят, что выражение `E1` гомеоморфно вкладывается в выражение `E2`
(обозначается как `E1 ⊴ E2`), если в выражении `E2` можно стереть какие-либо
элементы (конструкторы, звенья списка и т.д.) таким образом, что получится
выражение `E2′`, совпадающее с `E1` без учёта имён переменных.

Формально:

* `x ⊴ y` — любая переменная (параметр) вкладывается в любую переменную
  (параметр),
* `C ⊴ C` — константа вкладывается в совпадающую с ней константу,
* `a ⊴ c(b1, …, bi, … bn)`, если `a ⊴ bi` — если выражение `a` вкладывается
  в одно из подвыражений `bi` выражения `c(b1, …, bn)`, то оно вкладывается
  во всё выражение,
* `c(a1, …, an) ⊴ c(b1, …, bn)` если `ai ⊴ bi` для всех `i ∈ 1…n` — два
  выражения имеют одинаковую «форму» и их подвыражения попарно вкладываются.

#### Примеры

1. Модельный Рефал:
   ```
   <Paired '(', e.X> ⊴ <Paired '((', e.X>
   'кадр' ⊴ 'кафедра'
   <F 'abc' e.X> ⊴ <F <G 'abcd' e.X, 'ef'>>
   ```
2. Подмножество Scheme:
   ```scheme
   (cons 'A e1) ⊴ (cons 'A (cons 'B e2))
   (cons 'B e1) ⊴ (cons 'A (cons 'B e2))
   (pair? s1 s2) ⊴ (if (pair? s3 s4) 'A 'B)
   ```
3. Подмножество Scala:
   ```
   Tree(Leaf(A), Leaf(x)) ⊴ Tree(Tree(Leaf(A), Leaf(f(y, z))), g(y, z))
   f(g(h(x))) ⊴ f(h(x))
   ```
   тут предполагается, что `x`, `y`, `z` — параметры.
4. SLL — см. [второй препринт](http://keldysh.ru/papers/2018/prep2018_209.pdf).
   В сущности, примеры для него будут выглядеть почти также, как и для
   модельной Scala, ведь конфигурации будут составлены из конструкторов,
   вызовов функций, констант (0-местных конструкторов) и параметров.

### Наиболее тесное обобщение
При суперкомпиляции языков с неассоциативными операциями, т.е. для всех, кроме
Рефала (в нём ассоциативна конкатенация) для обобщения двух выражений
часто используют алгоритм наиболее тесного обобщения (most specific
generalization, MSG).

Данный алгоритм, будучи применён к двум выражениям `E1` и `E2`, вычисляет
выражение `E*` и две подстановки `S1` и `S2`, такие что

    E1 = E* / S1
    E2 = E* / S2

Алгоритм работает по шагам и на каждом шаге преобразует тройку `(E*, S1, S2)`
по двум правилам, описанным ниже, до тех пор, пока какое-нибудь из правил
является применимым. Если ни одно из правил применить нельзя, то данная тройка
и есть искомый результат.

Тройка инициализируется как `(x, { x → E1 }, { x → E2 })`, где `x` — имя новой
переменной (не встречающейся в `E1` и `E2`).

* **Правило первое.** Если есть такая переменная `x`, что
  ```
  x → C(e11, …, e1n)  ∈  S1
  x → C(e21, …, e2n)  ∈  S2
  ```
  где `C(…)` — некоторая синтаксическая конструкция (узел абстактного
  синтаксического дерева), а `eij` — дочерние узлы синтаксических деревьев,
  то вводятся `n` новых переменных `v1, …, vn` и тройка модифицируется
  следующим образом:
  ```
  E*′ = E* / { x → C1(v1, …, vn) }
  S1′ = S1 \ { x → C(e11, …, e1n) } ⋃ { v1 → e11, …, vn → e1n }
  S2′ = S2 \ { x → C(e21, …, e2n) } ⋃ { v1 → e21, …, vn → e2n }
  ```
  т.е. конструкция `C(…)` уходит в обобщение `E*`, а в подстановках остаются
  «дети» этой конструкции.
* **Правило второе.** Если есть такие переменные `x` и `y`, что
  ```
  x → e1, y → e1  ∈  S1
  x → e2, y → e2  ∈  S1
  ```
  т.е. эти переменные заменяются на одинаковые выражения в обоих подстановках,
  то тройка модифицируется следующим образом:
  ```
  E*′ = E* / { y → x }
  S1′ = S1 \ { y → e1 }
  S2′ = S2 \ { y → e2 }
  ```
  т.е. в обобщении `E*` переменная `y` заменяется на `x`, из подстановок `S1`
  и `S2` удаляются подстановки для `y`.


Варианты заданий
----------------
Знаком (\*) помечены задачи повышенного уровня сложности — +5 баллов.

Варианты по выбору студента, каждый вариант могут делать не более
двух студентов из каждой группы.

В рамках каждого из вариантов лабораторной работы нужно для выбранного
модельного языка описать абстрактное синтаксическое дерево с использованием
case-классов (достаточно ту его часть, которая используется в алгоритме)
и реализовать сам алгоритм. В частности, синтаксическое дерево для программы
требуется лишь в задачах на прогонку, в задачах на обобщение и отношение
Хигмана-Крускала достаточно абстрактного синтаксического дерева для
представления конфигураций.

Корректность алгоритма должна быть продемонстрирована путём написания
автотестов.

1.  (\*\*) Рефал: шаг прогонки, семантика call-by-value.

    Семантика call-by-value подразумевает, что в аргументе вызываемой функции
    других вызовов функций быть не может.

    Задание помечено как дважды сложное и это не случайно. Дело в том, что
    сопоставление с образцом в одном предложении может дать сразу несколько
    потомков.

    Рассмотрим следующую программу:

    ```
    F {
      '*', eY = eY;
      eX, eY = eX eY;
    }
    ```

    и следующую конфигурацию:

    ```
    <F <F e1 e2, e1>, e2>
    ```

    Прогоняться будет внутренний вызов `F` (т.к. семантика call-by-value),
    прогонка даст следующих потомков:

    * `e1 → '*', e2 → ε, <F '*', ε>`
    * `e1 → ε, e2 → '*', <F ε, '*'>`
    * `true, <F e1 e2 e1, e2>`

    Первое предложение дало первых двух потомков, второе — третьего потомка.

    Алгоритм прогонки можно найти в статье Турчина

    * В. Ф. Турчин. Эквивалентные преобразования рекурсивных функций, описанных
      на языке РЕФАЛ. В cб.: Труды симпозиума «Теория языков и методы
      построения систем программирования», Киев-Алушта: 1972. Стр. 31-42
      [скан](1972-Turchin--E'kvivalentnye_preobrazovaniya_rekursivnyx_funkcij__opisannyx_na_yazyke_Refal--ru.djvu),
      [перепечатано](1972-Turchin--E'kvivalentnye_preobrazovaniya_rekursivnyx_funkcij__opisannyx_na_yazyke_Refal--facsimile--ru.djvu)

2.  (\*) Рефал: проверка вложения Хигмана-Крускала.

    Здесь тонкость состоит в том, что допускается стирать вызовы функций,
    но при этом сохранять их аргументы:

    * `<G 'штукатурка'> ⊴ <G <F 'штука', 'турка'>>`

3.  (\*) Рефал: обобщение двух выражений.

    В других вариантах написано про построение «наиболее тесного обобщения»,
    но не для Рефала. Дело в том, что алгоритм построения наиболее тесного
    обобщения в том виде, в каком он описан, к Рефалу применим плохо: из-за
    ассоциативности конкатенации и наличия e-переменных он будет
    недетерминированным и поэтому экспоненциально сложным.

    Более того, обобщение в Рефале неоднозначно, например, для конфигураций
    `<F 'abra'>` и `<F 'abracadabra'>` получатся как минимум следующие
    обобщения:

    * `<F 'abra' e1>`
    * `<F 'abr' e1 'a' e2>`
    * `<F 'ab' e1 'ra'>`
    * и так далее

    Требуется написать алгоритм, который находит какое-то одно нетривиальное
    обобщение. (Очевидно, что для любой пары конфигураций всегда есть
    тривиальное обобщение до одного e-параметра `e1`, но такое обобщение
    на практике не интересно.)

4.  (\*) Scheme: шаг прогонки, семантика call-by-name.

    Детали алгоритма прогонки описаны выше при рассмотрении представления
    конфигураций и обсуждении семантик call-by-value и call-by-name.

5.  Scheme: проверка вложения Хигмана-Крускала.
6.  Scheme: наиболее тесное обобщение двух выражений.
7.  (\*) Scala: шаг прогонки, семантика call-by-value.

    Семантика call-by-value означает, что в аргументе прогоняемой функции
    не может быть вызовов других функций.

    Задача выполнения прогонки включает в себя задачу _унификации_ двух
    выражений, параметризованного аргумента и образца. Алгоритм унификации
    должен находить две подстановки: подстановку для параметров аргумента
    и подстановку для переменных образца, такие, что применение их,
    соответственно, к аргументу и образцу, дают одинаковое выражение.

8.  Scala: проверка вложения Хигмана-Крускала.
9.  Scala: наиболее тесное обобщение двух выражений.
10. (\*) SLL: шаг прогонки, семантика call-by-name (см. препринты).
11. SLL: проверка вложения Хигмана-Крускала (см. препринты).
12. SLL: наиболее тесное обобщение двух выражений (см. препринты).
